from __future__ import annotations

from collections.abc import Sequence
from typing import Any, overload

from ..flint_base.flint_base import flint_poly
from .acb import acb
from .arb import arb
from .fmpq import fmpq
from .fmpq_poly import fmpq_poly
from .fmpz import fmpz
from .fmpz_poly import fmpz_poly


ifmpz = int | fmpz
ifmpq = int | fmpz | fmpq
iarf = int | float | fmpz | fmpq | arb
iarb_poly = arb_poly | int | float | fmpz | fmpq | arb | fmpz_poly | fmpq_poly


class arb_poly(flint_poly[arb]):
    def __init__(self, val: arb_poly | fmpz_poly | fmpq_poly | Sequence[iarf] | iarf | None = ...) -> None: ...

    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def degree(self) -> int: ...

    def __getitem__(self, i: int, /) -> arb: ...
    def __setitem__(self, i: int, x: iarf, /) -> None: ...

    def repr(self) -> str: ...

    @classmethod
    def from_roots(cls, roots: Sequence[iarf]) -> arb_poly: ...

    def complex_roots(self, **kwargs: Any) -> list[Any]: ...

    def evaluate(self, xs: Sequence[iarf], algorithm: str = "fast") -> list[arb]: ...

    @classmethod
    def interpolate(cls, xs: Sequence[iarf], ys: Sequence[iarf], algorithm: str = "fast") -> arb_poly: ...

    def derivative(self) -> arb_poly: ...
    def integral(self) -> arb_poly: ...

    def __pos__(self) -> arb_poly: ...
    def __neg__(self) -> arb_poly: ...

    def __add__(self, other: iarb_poly, /) -> arb_poly: ...
    def __radd__(self, other: iarb_poly, /) -> arb_poly: ...
    def __sub__(self, other: iarb_poly, /) -> arb_poly: ...
    def __rsub__(self, other: iarb_poly, /) -> arb_poly: ...
    def __mul__(self, other: iarb_poly, /) -> arb_poly: ...
    def __rmul__(self, other: iarb_poly, /) -> arb_poly: ...

    def __floordiv__(self, other: iarb_poly, /) -> arb_poly: ...
    def __rfloordiv__(self, other: iarb_poly, /) -> arb_poly: ...
    def __mod__(self, other: iarb_poly, /) -> arb_poly: ...
    def __rmod__(self, other: iarb_poly, /) -> arb_poly: ...
    def __divmod__(self, other: iarb_poly, /) -> tuple[arb_poly, arb_poly]: ...
    def __rdivmod__(self, other: iarb_poly, /) -> tuple[arb_poly, arb_poly]: ...

    def truncate(self, n: int, /) -> arb_poly: ...
    def left_shift(self, n: int, /) -> arb_poly: ...
    def right_shift(self, n: int, /) -> arb_poly: ...

    def __pow__(self, exp: int, mod: None = ..., /) -> arb_poly: ...

    @overload
    def __call__(self, t: arb_poly, /) -> arb_poly: ...
    @overload
    def __call__(self, t: fmpz_poly | fmpq_poly, /) -> arb_poly: ...
    @overload
    def __call__(self, t: iarf, /) -> arb: ...
    @overload
    def __call__(self, t: acb | complex, /) -> acb: ...

    def unique_fmpz_poly(self) -> fmpz_poly | None: ...

from __future__ import annotations

from collections.abc import Callable, Sequence
from typing import Any, overload

from ..flint_base.flint_base import flint_series
from .arb import arb
from .arb_poly import arb_poly
from .fmpq import fmpq
from .fmpq_poly import fmpq_poly
from .fmpq_series import fmpq_series
from .fmpz import fmpz
from .fmpz_poly import fmpz_poly
from .fmpz_series import fmpz_series


ifmpz = int | fmpz
ifmpq = int | fmpz | fmpq
iarf = int | float | fmpz | fmpq | arb
iarf_series = arb_series | iarf | fmpz_poly | fmpq_poly | fmpz_series | fmpq_series | arb_poly


class arb_series(flint_series[arb]):
    def __init__(self, val: arb_series | fmpz_series | fmpq_series | fmpz_poly | fmpq_poly | arb_poly | Sequence[iarf] | iarf | None = ..., prec: int | None = ...) -> None: ...

    @property
    def prec(self) -> int: ...

    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def __getitem__(self, i: int, /) -> arb: ...
    def __setitem__(self, i: int, x: iarf, /) -> None: ...

    def repr(self, **kwargs: object) -> str: ...
    def str(self, *args: object, **kwargs: object) -> str: ...

    def __pos__(self) -> arb_series: ...
    def __neg__(self) -> arb_series: ...
    def __add__(self, other: iarf_series, /) -> arb_series: ...
    def __radd__(self, other: iarf_series, /) -> arb_series: ...
    def __sub__(self, other: iarf_series, /) -> arb_series: ...
    def __rsub__(self, other: iarf_series, /) -> arb_series: ...
    def __mul__(self, other: iarf_series, /) -> arb_series: ...
    def __rmul__(self, other: iarf_series, /) -> arb_series: ...
    def __truediv__(self, other: iarf_series, /) -> arb_series: ...
    def __rtruediv__(self, other: iarf_series, /) -> arb_series: ...
    def __pow__(self, other: iarf_series, mod: None = ..., /) -> arb_series: ...
    def __rpow__(self, other: iarf_series, mod: None = ..., /) -> arb_series: ...

    def valuation(self) -> int: ...

    def __call__(self, other: arb_series, /) -> arb_series: ...
    def reversion(self) -> arb_series: ...
    def inv(self) -> arb_series: ...
    def derivative(self) -> arb_series: ...
    def integral(self) -> arb_series: ...

    def sqrt(self) -> arb_series: ...
    def rsqrt(self) -> arb_series: ...
    def exp(self) -> arb_series: ...
    def log(self) -> arb_series: ...
    def atan(self) -> arb_series: ...
    def asin(self) -> arb_series: ...
    def acos(self) -> arb_series: ...
    def sin(self) -> arb_series: ...
    def cos(self) -> arb_series: ...
    def sin_cos(self) -> tuple[arb_series, arb_series]: ...
    def sin_pi(self) -> arb_series: ...
    def cos_pi(self) -> arb_series: ...
    def sin_cos_pi(self) -> tuple[arb_series, arb_series]: ...
    def cot_pi(self) -> arb_series: ...
    def tan(self) -> arb_series: ...

    def gamma(self) -> arb_series: ...
    def rgamma(self) -> arb_series: ...
    def lgamma(self) -> arb_series: ...
    def rising(self, n: int, /) -> arb_series: ...
    def zeta(self, a: iarf = ..., deflate: bool = ...) -> arb_series: ...
    def riemann_siegel_theta(self) -> arb_series: ...
    def riemann_siegel_z(self) -> arb_series: ...

    def erf(self) -> arb_series: ...
    def erfc(self) -> arb_series: ...
    def erfi(self) -> arb_series: ...
    def fresnel(self, normalized: bool = ...) -> tuple[arb_series, arb_series]: ...
    def fresnel_s(self, normalized: bool = ...) -> arb_series: ...
    def fresnel_c(self, normalized: bool = ...) -> arb_series: ...
    def ei(self) -> arb_series: ...
    def si(self) -> arb_series: ...
    def ci(self) -> arb_series: ...
    def shi(self) -> arb_series: ...
    def chi(self) -> arb_series: ...
    def li(self, offset: bool = ...) -> arb_series: ...

    def airy_ai(self) -> arb_series: ...
    def airy_ai_prime(self) -> arb_series: ...
    def airy_bi(self) -> arb_series: ...
    def airy_bi_prime(self) -> arb_series: ...
    def airy(self) -> tuple[arb_series, arb_series, arb_series, arb_series]: ...

    def coulomb(self, l: iarf, eta: iarf) -> tuple[arb_series, arb_series]: ...
    def coulomb_f(self, l: iarf, eta: iarf) -> arb_series: ...
    def coulomb_g(self, l: iarf, eta: iarf) -> arb_series: ...

    @classmethod
    def gamma_upper(cls, s: iarf, z: iarf_series, regularized: int = ...) -> arb_series: ...
    @classmethod
    def gamma_lower(cls, s: iarf, z: iarf_series, regularized: int = ...) -> arb_series: ...
    @classmethod
    def beta_lower(cls, a: iarf, b: iarf, z: iarf_series, regularized: int = ...) -> arb_series: ...

    def lambertw(self, branch: int = ...) -> arb_series: ...

    @staticmethod
    def find_roots(f: Callable[[arb_series], arb_series], a: iarf, b: iarf, maxn: int = ...) -> list[tuple[arb, arb]]: ...

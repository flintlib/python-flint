from __future__ import annotations

from collections.abc import Sequence
from typing import Any, overload

from ..flint_base.flint_base import flint_poly
from .acb import acb
from .arb import arb
from .arb_poly import arb_poly
from .fmpq import fmpq
from .fmpq_poly import fmpq_poly
from .fmpz import fmpz
from .fmpz_poly import fmpz_poly


ifmpz = int | fmpz
ifmpq = int | fmpz | fmpq
iarf = int | float | fmpz | fmpq | arb
iacb = int | float | complex | str | fmpz | fmpq | arb | acb
iacb_poly = acb_poly | iacb | fmpz_poly | fmpq_poly | arb_poly


class acb_poly(flint_poly[acb]):
    def __init__(
        self,
        val: acb_poly | arb_poly | fmpz_poly | fmpq_poly | Sequence[iacb] | iacb | None = ...,
    ) -> None: ...

    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def degree(self) -> int: ...

    def __getitem__(self, i: int, /) -> acb: ...
    def __setitem__(self, i: int, x: iacb, /) -> None: ...

    def repr(self) -> str: ...

    @classmethod
    def from_roots(cls, roots: Sequence[iacb]) -> acb_poly: ...

    def evaluate(self, xs: Sequence[iacb], algorithm: str = "fast") -> list[acb]: ...

    @classmethod
    def interpolate(cls, xs: Sequence[iacb], ys: Sequence[iacb], algorithm: str = "fast") -> acb_poly: ...

    def derivative(self) -> acb_poly: ...
    def integral(self) -> acb_poly: ...

    def __pos__(self) -> acb_poly: ...
    def __neg__(self) -> acb_poly: ...

    def __add__(self, other: iacb_poly, /) -> acb_poly: ...
    def __radd__(self, other: iacb_poly, /) -> acb_poly: ...
    def __sub__(self, other: iacb_poly, /) -> acb_poly: ...
    def __rsub__(self, other: iacb_poly, /) -> acb_poly: ...
    def __mul__(self, other: iacb_poly, /) -> acb_poly: ...
    def __rmul__(self, other: iacb_poly, /) -> acb_poly: ...

    def __floordiv__(self, other: iacb_poly, /) -> acb_poly: ...
    def __rfloordiv__(self, other: iacb_poly, /) -> acb_poly: ...
    def __mod__(self, other: iacb_poly, /) -> acb_poly: ...
    def __rmod__(self, other: iacb_poly, /) -> acb_poly: ...
    def __divmod__(self, other: iacb_poly, /) -> tuple[acb_poly, acb_poly]: ...
    def __rdivmod__(self, other: iacb_poly, /) -> tuple[acb_poly, acb_poly]: ...

    def truncate(self, n: int, /) -> acb_poly: ...
    def left_shift(self, n: int, /) -> acb_poly: ...
    def right_shift(self, n: int, /) -> acb_poly: ...

    def __pow__(self, exp: int, mod: None = ..., /) -> acb_poly: ...

    @overload
    def __call__(self, t: acb_poly, /) -> acb_poly: ...
    @overload
    def __call__(self, t: fmpz_poly | fmpq_poly | arb_poly, /) -> acb_poly: ...
    @overload
    def __call__(self, t: iacb, /) -> acb: ...

    def unique_fmpz_poly(self) -> fmpz_poly | None: ...
    def roots(self, tol: iarf | None = None, maxprec: int | None = None) -> list[acb]: ...  # type: ignore[override]
    def complex_roots(self, tol: iarf | None = None, maxprec: int | None = None) -> list[acb]: ...
    def root_bound(self) -> arb: ...

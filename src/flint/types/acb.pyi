from collections.abc import Callable, Iterable
from typing import Protocol, overload

from ..flint_base.flint_base import flint_scalar
from .arb import arb
from .arf import arf
from .fmpq import fmpq as fmpq_t
from .fmpz import fmpz as fmpz_t


_str = str
ifmpz = int | fmpz_t
ifmpq = int | fmpz_t | fmpq_t
iarf = int | float | fmpz_t | fmpq_t | arf
iarb = int | float | fmpz_t | fmpq_t | arf | arb
iacb = int | float | complex | fmpz_t | fmpq_t | arf | arb | acb


class _MpcLike(Protocol):
    _mpc_: tuple[object, object]


class acb(flint_scalar):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, real: iacb | tuple[ifmpz, ifmpz] | _str | _MpcLike, imag: iarb | tuple[ifmpz, ifmpz] | _str | None = ...) -> None: ...

    def is_zero(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_exact(self) -> bool: ...

    @property
    def real(self) -> arb: ...
    @property
    def imag(self) -> arb: ...
    @property
    def _mpc_(self) -> tuple[object, object]: ...

    def __contains__(self, other: iacb, /) -> bool: ...
    def contains(self, other: iacb, /) -> bool: ...
    def contains_interior(self, other: iacb, /) -> bool: ...
    def overlaps(self, other: iacb, /) -> bool: ...
    def contains_integer(self) -> bool: ...

    def mid(self) -> acb: ...
    def rad(self) -> arb: ...
    def complex_rad(self) -> acb: ...

    def repr(self) -> _str: ...
    def str(self, *args: object, **kwargs: object) -> _str: ...
    def __str__(self) -> _str: ...
    def __repr__(self) -> _str: ...

    def __complex__(self) -> complex: ...

    def __pos__(self) -> acb: ...
    def __neg__(self) -> acb: ...
    def neg(self, exact: bool = False) -> acb: ...
    def conjugate(self, exact: bool = False) -> acb: ...

    def __abs__(self) -> arb: ...
    def abs_lower(self) -> arb: ...
    def abs_upper(self) -> arb: ...
    def csgn(self) -> arb: ...
    def sgn(self) -> acb: ...
    def arg(self) -> arb: ...

    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...

    def __add__(self, other: iacb, /) -> acb: ...
    def __radd__(self, other: iacb, /) -> acb: ...
    def __sub__(self, other: iacb, /) -> acb: ...
    def __rsub__(self, other: iacb, /) -> acb: ...
    def __mul__(self, other: iacb, /) -> acb: ...
    def __rmul__(self, other: iacb, /) -> acb: ...
    def __truediv__(self, other: iacb, /) -> acb: ...
    def __rtruediv__(self, other: iacb, /) -> acb: ...
    def __pow__(self, other: iacb, modulus: None = ..., /) -> acb: ...
    def __rpow__(self, other: iacb, modulus: None = ..., /) -> acb: ...

    def union(self, t: iacb) -> acb: ...

    def pow(self, t: iacb, analytic: bool = False) -> acb: ...
    def log(self, analytic: bool = False) -> acb: ...
    def log1p(self) -> acb: ...
    def asin(self) -> acb: ...
    def acos(self) -> acb: ...
    def atan(self) -> acb: ...
    def asinh(self) -> acb: ...
    def acosh(self) -> acb: ...
    def atanh(self) -> acb: ...

    def agm(self, t: iacb | None = None) -> acb: ...

    def gamma(self) -> acb: ...
    def rgamma(self) -> acb: ...
    def lgamma(self) -> acb: ...
    def digamma(self) -> acb: ...
    def zeta(self, a: iacb | None = None) -> acb: ...
    def lerch_phi(self, s: iacb, a: iacb) -> acb: ...
    def dirichlet_l(self, chi: object) -> acb: ...

    @staticmethod
    def pi() -> acb: ...

    def sqrt(self, analytic: bool = False) -> acb: ...
    def rsqrt(self, analytic: bool = False) -> acb: ...
    def exp(self) -> acb: ...
    def exp_pi_i(self) -> acb: ...
    def expm1(self) -> acb: ...

    def sin(self) -> acb: ...
    def cos(self) -> acb: ...
    def sin_cos(self) -> tuple[acb, acb]: ...
    def tan(self) -> acb: ...
    def cot(self) -> acb: ...
    def sin_pi(self) -> acb: ...
    def cos_pi(self) -> acb: ...
    def sin_cos_pi(self) -> tuple[acb, acb]: ...
    def tan_pi(self) -> acb: ...
    def cot_pi(self) -> acb: ...
    def sec(self) -> acb: ...
    def csc(self) -> acb: ...

    def sinh(self) -> acb: ...
    def cosh(self) -> acb: ...
    def sinh_cosh(self) -> tuple[acb, acb]: ...
    def tanh(self) -> acb: ...
    def coth(self) -> acb: ...
    def sech(self) -> acb: ...
    def csch(self) -> acb: ...

    def sinc(self) -> acb: ...
    def sinc_pi(self) -> acb: ...

    def rising(self, n: iacb) -> acb: ...
    def rising2(self, n: int) -> tuple[acb, acb]: ...
    def polylog(self, s: iacb) -> acb: ...

    def erf(self) -> acb: ...
    def erfc(self) -> acb: ...
    def erfi(self) -> acb: ...

    @staticmethod
    def modular_theta(z: iacb, tau: iacb, r: int = 0) -> tuple[acb, acb, acb, acb]: ...
    def modular_eta(self) -> acb: ...
    def modular_j(self) -> acb: ...
    def modular_lambda(self) -> acb: ...
    def modular_delta(self) -> acb: ...

    def elliptic_k(self) -> acb: ...
    def elliptic_e(self) -> acb: ...

    def unique_fmpz(self) -> fmpz_t | None: ...

    def gamma_upper(self, s: iacb, regularized: int = 0) -> acb: ...
    def gamma_lower(self, s: iacb, regularized: int = 0) -> acb: ...
    def beta_lower(self, a: iacb, b: iacb, regularized: int = 0) -> acb: ...
    def expint(self, s: iacb) -> acb: ...

    def rel_accuracy_bits(self) -> int: ...
    def rel_one_accuracy_bits(self) -> int: ...
    def bits(self) -> int: ...

    def ei(self) -> acb: ...
    def si(self) -> acb: ...
    def ci(self) -> acb: ...
    def shi(self) -> acb: ...
    def chi(self) -> acb: ...
    def li(self, offset: bool = False) -> acb: ...

    def hypgeom_2f1(
        self,
        a: iacb,
        b: iacb,
        c: iacb,
        regularized: bool = False,
        ab: bool = False,
        ac: bool = False,
        bc: bool = False,
        abc: bool = False,
    ) -> acb: ...

    def chebyshev_t(self, n: iacb) -> acb: ...
    def chebyshev_u(self, n: iacb) -> acb: ...
    def jacobi_p(self, n: iacb, a: iacb, b: iacb) -> acb: ...
    def gegenbauer_c(self, n: iacb, m: iacb) -> acb: ...
    def laguerre_l(self, n: iacb, m: iacb = 0) -> acb: ...
    def hermite_h(self, n: iacb) -> acb: ...
    def legendre_p(self, n: iacb, m: iacb = 0, type: int = 2) -> acb: ...
    def legendre_q(self, n: iacb, m: iacb = 0, type: int = 2) -> acb: ...

    @staticmethod
    def spherical_y(n: int, m: int, theta: iacb, phi: iacb) -> acb: ...

    def airy_ai(self, derivative: int = 0) -> acb: ...
    def airy_bi(self, derivative: int = 0) -> acb: ...
    def airy(self) -> tuple[acb, acb, acb, acb]: ...

    def lambertw(self, branch: ifmpz = 0, left: bool = False, middle: bool = False) -> acb: ...

    def real_abs(self, analytic: bool = False) -> acb: ...
    def real_sgn(self, analytic: bool = False) -> acb: ...
    def real_heaviside(self, analytic: bool = False) -> acb: ...
    def real_floor(self, analytic: bool = False) -> acb: ...
    def real_ceil(self, analytic: bool = False) -> acb: ...
    def real_max(self, t: iacb, analytic: bool = False) -> acb: ...
    def real_min(self, t: iacb, analytic: bool = False) -> acb: ...
    def real_sqrt(self, analytic: bool = False) -> acb: ...

    @staticmethod
    def stieltjes(n: ifmpz, a: iacb = 1) -> acb: ...

    def bernoulli_poly(self, n: int) -> acb: ...

    @staticmethod
    def dft(vec: Iterable[iacb], inverse: bool = False) -> list[acb]: ...

    def fresnel_s(self, normalized: bool = True) -> acb: ...
    def fresnel_c(self, normalized: bool = True) -> acb: ...
    def log_sin_pi(self) -> acb: ...

    @staticmethod
    def elliptic_rf(x: iacb, y: iacb, z: iacb) -> acb: ...
    @staticmethod
    def elliptic_rc(x: iacb, y: iacb) -> acb: ...
    @staticmethod
    def elliptic_rj(x: iacb, y: iacb, z: iacb, p: iacb) -> acb: ...
    @staticmethod
    def elliptic_rd(x: iacb, y: iacb, z: iacb) -> acb: ...
    @staticmethod
    def elliptic_rg(x: iacb, y: iacb, z: iacb) -> acb: ...

    @staticmethod
    def elliptic_f(phi: iacb, m: iacb, pi: bool = False) -> acb: ...
    @staticmethod
    def elliptic_e_inc(phi: iacb, m: iacb, pi: bool = False) -> acb: ...
    @staticmethod
    def elliptic_pi(n: iacb, m: iacb) -> acb: ...
    @staticmethod
    def elliptic_pi_inc(n: iacb, phi: iacb, m: iacb, pi: bool = False) -> acb: ...

    def elliptic_p(self, tau: iacb) -> acb: ...
    def elliptic_zeta(self, tau: iacb) -> acb: ...
    def elliptic_sigma(self, tau: iacb) -> acb: ...
    def elliptic_inv_p(self, tau: iacb) -> acb: ...
    def elliptic_roots(self) -> tuple[acb, acb, acb]: ...
    def elliptic_invariants(self) -> tuple[acb, acb]: ...

    def dirichlet_eta(self) -> acb: ...
    def polygamma(self, s: iacb) -> acb: ...
    def log_barnes_g(self) -> acb: ...
    def barnes_g(self) -> acb: ...

    def hypgeom_0f1(self, a: iacb, regularized: bool = False) -> acb: ...
    def hypgeom(self, a: list[iacb], b: list[iacb], regularized: bool = False, n: int = -1) -> acb: ...
    def hypgeom_u(self, a: iacb, b: iacb, n: int = -1, asymp: bool = False) -> acb: ...
    def hypgeom_1f1(self, a: iacb, b: iacb, regularized: bool = False) -> acb: ...

    def bessel_j(self, n: iacb) -> acb: ...
    def bessel_y(self, n: iacb) -> acb: ...
    def bessel_k(self, n: iacb, scaled: bool = False) -> acb: ...
    def bessel_i(self, n: iacb, scaled: bool = False) -> acb: ...

    def root(self, n: int) -> acb: ...

    @staticmethod
    def zeta_zero(n: ifmpz) -> acb: ...
    @staticmethod
    def zeta_zeros(n: ifmpz, num: int) -> list[acb]: ...

    @staticmethod
    def integral(
        func: Callable[[acb, bool], object],
        a: iacb,
        b: iacb,
        params: object | None = None,
        rel_tol: iarb | None = None,
        abs_tol: iarb | None = None,
        deg_limit: int | None = None,
        eval_limit: int | None = None,
        depth_limit: int | None = None,
        use_heap: bool | None = None,
        verbose: bool | None = None,
    ) -> acb: ...

    def coulomb(self, l: iacb, eta: iacb) -> tuple[acb, acb, acb, acb]: ...
    def coulomb_f(self, l: iacb, eta: iacb) -> acb: ...
    def coulomb_g(self, l: iacb, eta: iacb) -> acb: ...

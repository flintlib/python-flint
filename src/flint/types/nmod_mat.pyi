from __future__ import annotations

from collections.abc import Iterable, Iterator, Sequence
from typing import overload

from flint.flint_base.flint_base import flint_mat
from flint.types.fmpz import fmpz
from flint.types.fmpz_mat import fmpz_mat
from flint.types.nmod import inmod, nmod
from flint.types.nmod_poly import nmod_poly

_str = str

inmod_mat = nmod_mat | fmpz_mat | Sequence[Sequence[inmod]]


class nmod_mat(flint_mat[nmod]):
    @overload
    def __init__(self, val: nmod_mat, /) -> None: ...
    @overload
    def __init__(self, val: fmpz_mat | Sequence[Sequence[inmod]], mod: int, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, mod: int, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, entries: Iterable[inmod], mod: int, /) -> None: ...

    def __bool__(self) -> bool: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...

    def nrows(self) -> int: ...
    def ncols(self) -> int: ...
    def modulus(self) -> int: ...
    @classmethod
    def randtest(cls, m: int, n: int, mod: int, /) -> nmod_mat: ...

    def __getitem__(self, index: tuple[int, int], /) -> nmod: ...
    def __setitem__(self, index: tuple[int, int], value: inmod, /) -> None: ...
    def __iter__(self) -> Iterator[nmod]: ...
    def entries(self) -> list[nmod]: ...
    def table(self) -> list[list[nmod]]: ...
    def tolist(self) -> list[list[nmod]]: ...

    def repr(self) -> _str: ...
    def __str__(self) -> _str: ...
    def __repr__(self) -> _str: ...

    def __pos__(self) -> nmod_mat: ...
    def __neg__(self) -> nmod_mat: ...
    def __add__(self, other: inmod_mat, /) -> nmod_mat: ...
    def __radd__(self, other: inmod_mat, /) -> nmod_mat: ...
    def __sub__(self, other: inmod_mat, /) -> nmod_mat: ...
    def __rsub__(self, other: inmod_mat, /) -> nmod_mat: ...
    def __mul__(self, other: inmod_mat | inmod, /) -> nmod_mat: ...
    def __rmul__(self, other: inmod_mat | inmod, /) -> nmod_mat: ...
    def __truediv__(self, other: inmod, /) -> nmod_mat: ...
    def __pow__(self, exponent: int, modulo: None = None, /) -> nmod_mat: ...

    def det(self) -> nmod: ...
    def inv(self) -> nmod_mat: ...
    def transpose(self) -> nmod_mat: ...
    def solve(self, other: inmod_mat, /) -> nmod_mat: ...
    def rref(self, inplace: bool = False, /) -> tuple[nmod_mat, int]: ...
    def rank(self) -> int: ...
    def nullspace(self) -> tuple[nmod_mat, int]: ...
    def charpoly(self) -> nmod_poly: ...
    def minpoly(self) -> nmod_poly: ...

from __future__ import annotations

from collections.abc import Iterable, Sequence
from typing import Any, Literal, Protocol, overload

from flint.flint_base.flint_base import flint_mat
from flint.types.acb import acb
from flint.types.acb_poly import acb_poly
from flint.types.arb import arb
from flint.types.arb_mat import arb_mat
from flint.types.fmpq import fmpq
from flint.types.fmpq_mat import fmpq_mat
from flint.types.fmpz import fmpz
from flint.types.fmpz_mat import fmpz_mat

_str = str
acb_scalar = int | float | complex | fmpz | fmpq | arb | acb
iacb = acb_scalar | str


class _MatrixLike(Protocol):
    rows: int
    cols: int

    def __getitem__(self, index: tuple[int, int], /) -> object: ...


class acb_mat(flint_mat[acb]):
    @classmethod
    def convert(cls, x: object, /) -> acb_mat: ...

    @overload
    def __init__(self, val: acb_mat | arb_mat | fmpz_mat | fmpq_mat | Sequence[Sequence[iacb]] | _MatrixLike, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, entries: iacb | Iterable[iacb], /) -> None: ...

    def __bool__(self) -> bool: ...
    def nrows(self) -> int: ...
    def ncols(self) -> int: ...
    def __getitem__(self, index: tuple[int, int], /) -> acb: ...
    def __setitem__(self, index: tuple[int, int], value: iacb, /) -> None: ...

    def transpose(self) -> acb_mat: ...
    def conjugate(self) -> acb_mat: ...
    def det(self) -> acb: ...
    def __pos__(self) -> acb_mat: ...
    def __neg__(self) -> acb_mat: ...

    def __add__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __radd__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __sub__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __rsub__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __mul__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __rmul__(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat | acb_scalar, /) -> acb_mat: ...
    def __truediv__(self, other: acb_scalar, /) -> acb_mat: ...
    def __pow__(self, exponent: int, modulo: object | None = None, /) -> acb_mat: ...

    def inv(self, nonstop: bool = False) -> acb_mat: ...
    def solve(
        self,
        rhs: acb_mat | arb_mat | fmpz_mat | fmpq_mat,
        nonstop: bool = False,
        algorithm: Literal["lu", "precond", "approx"] | None = None,
    ) -> acb_mat: ...
    def exp(self) -> acb_mat: ...
    def charpoly(self) -> acb_poly: ...
    def mid(self) -> acb_mat: ...
    def trace(self) -> acb: ...

    @classmethod
    def dft(cls, n: int, m: int = -1, /) -> acb_mat: ...

    def overlaps(self, other: acb_mat, /) -> bool: ...
    def contains(self, other: acb_mat | arb_mat | fmpz_mat | fmpq_mat, /) -> bool: ...
    def chop(self, tol: iacb, /) -> acb_mat: ...

    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...

    @property
    def real(self) -> arb_mat: ...
    @property
    def imag(self) -> arb_mat: ...

    def eig(
        self,
        left: bool = False,
        right: bool = False,
        multiple: bool = False,
        algorithm: Literal["rump", "vdhoeven_mourrain", "approx"] | None = None,
        tol: iacb | None = None,
        maxiter: int = 0,
        nonstop: bool = False,
    ) -> Any: ...

    def theta(self, z: acb_mat, square: bool = False) -> acb_mat: ...

    def str(self, n: int = 0, radius: bool = True, more: bool = False, condense: int = 0) -> _str: ...
    def repr(self) -> _str: ...
    def __str__(self) -> _str: ...
    def __repr__(self) -> _str: ...

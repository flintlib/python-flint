from __future__ import annotations

from collections.abc import Iterable, Sequence
from typing import Any, Literal, Protocol, overload

from flint.flint_base.flint_base import flint_mat
from flint.types.acb import acb
from flint.types.arb import arb
from flint.types.arb_poly import arb_poly
from flint.types.fmpq import fmpq
from flint.types.fmpq_mat import fmpq_mat
from flint.types.fmpz import fmpz
from flint.types.fmpz_mat import fmpz_mat

_str = str
iarb = int | float | str | fmpz | fmpq | arb


class _MatrixLike(Protocol):
    rows: int
    cols: int

    def __getitem__(self, index: tuple[int, int], /) -> object: ...


class arb_mat(flint_mat[arb]):
    @classmethod
    def convert(cls, x: object, /) -> arb_mat: ...

    @overload
    def __init__(self, val: arb_mat | fmpz_mat | fmpq_mat | Sequence[Sequence[iarb]] | _MatrixLike, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, /) -> None: ...
    @overload
    def __init__(self, m: int, n: int, entries: iarb | Iterable[iarb], /) -> None: ...

    def __bool__(self) -> bool: ...
    def nrows(self) -> int: ...
    def ncols(self) -> int: ...
    def __getitem__(self, index: tuple[int, int], /) -> arb: ...
    def __setitem__(self, index: tuple[int, int], value: iarb, /) -> None: ...
    def transpose(self) -> arb_mat: ...
    def det(self) -> arb: ...
    def __pos__(self) -> arb_mat: ...
    def __neg__(self) -> arb_mat: ...

    @overload
    def __add__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __add__(self, other: complex | acb, /) -> flint_mat: ...
    @overload
    def __radd__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __radd__(self, other: complex | acb, /) -> flint_mat: ...
    @overload
    def __sub__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __sub__(self, other: complex | acb, /) -> flint_mat: ...
    @overload
    def __rsub__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __rsub__(self, other: complex | acb, /) -> flint_mat: ...
    @overload
    def __mul__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __mul__(self, other: complex | acb, /) -> flint_mat: ...
    @overload
    def __rmul__(self, other: arb_mat | fmpz_mat | fmpq_mat | iarb, /) -> arb_mat: ...
    @overload
    def __rmul__(self, other: complex | acb, /) -> flint_mat: ...
    def __truediv__(self, other: iarb, /) -> arb_mat: ...
    def __pow__(self, exponent: int, modulo: object | None = None, /) -> arb_mat: ...

    def inv(self, nonstop: bool = False) -> arb_mat: ...
    def solve(
        self,
        rhs: arb_mat | fmpz_mat | fmpq_mat,
        nonstop: bool = False,
        algorithm: Literal["lu", "precond", "approx"] | None = None,
    ) -> arb_mat: ...
    def exp(self) -> arb_mat: ...
    def charpoly(self) -> arb_poly: ...
    def mid(self) -> arb_mat: ...
    def trace(self) -> arb: ...

    @classmethod
    def hilbert(cls, n: int, m: int, /) -> arb_mat: ...
    @classmethod
    def pascal(cls, n: int, m: int, triangular: int = 0, /) -> arb_mat: ...
    @classmethod
    def stirling(cls, n: int, m: int, kind: int = 0, /) -> arb_mat: ...
    @classmethod
    def dct(cls, n: int, m: int = -1, /) -> arb_mat: ...

    def overlaps(self, other: arb_mat, /) -> bool: ...
    def contains(self, other: arb_mat | fmpz_mat | fmpq_mat, /) -> bool: ...
    def chop(self, tol: iarb, /) -> arb_mat: ...

    def __eq__(self, other: object, /) -> bool: ...
    def __ne__(self, other: object, /) -> bool: ...
    def eig(self, *args: Any, **kwargs: Any) -> Any: ...

    def str(self, n: int = 0, radius: bool = True, more: bool = False, condense: int = 0) -> _str: ...
    def repr(self) -> _str: ...
    def __str__(self) -> _str: ...
    def __repr__(self) -> _str: ...

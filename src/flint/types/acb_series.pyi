from __future__ import annotations

from collections.abc import Sequence

from ..flint_base.flint_base import flint_series
from .acb import acb
from .acb_poly import acb_poly
from .arb import arb
from .arb_poly import arb_poly
from .arb_series import arb_series
from .fmpq import fmpq
from .fmpq_poly import fmpq_poly
from .fmpq_series import fmpq_series
from .fmpz import fmpz
from .fmpz_poly import fmpz_poly
from .fmpz_series import fmpz_series

ifmpz = int | fmpz
ifmpq = int | fmpz | fmpq
iarf = int | float | fmpz | fmpq | arb
iacb = int | float | complex | str | fmpz | fmpq | arb | acb
iacb_series = acb_series | iacb | fmpz_poly | fmpq_poly | fmpz_series | fmpq_series | arb_poly | arb_series | acb_poly


class acb_series(flint_series[acb]):
    def __init__(self, val: acb_series | arb_series | fmpz_series | fmpq_series | fmpz_poly | fmpq_poly | acb_poly | Sequence[iacb] | iacb | None = ..., prec: int | None = ...) -> None: ...

    @property
    def prec(self) -> int: ...

    def __len__(self) -> int: ...
    def length(self) -> int: ...
    def __getitem__(self, i: int, /) -> acb: ...
    def __setitem__(self, i: int, x: iacb, /) -> None: ...

    def repr(self, **kwargs: object) -> str: ...
    def str(self, *args: object, **kwargs: object) -> str: ...

    def __pos__(self) -> acb_series: ...
    def __neg__(self) -> acb_series: ...
    def __add__(self, other: iacb_series, /) -> acb_series: ...
    def __radd__(self, other: iacb_series, /) -> acb_series: ...
    def __sub__(self, other: iacb_series, /) -> acb_series: ...
    def __rsub__(self, other: iacb_series, /) -> acb_series: ...
    def __mul__(self, other: iacb_series, /) -> acb_series: ...
    def __rmul__(self, other: iacb_series, /) -> acb_series: ...
    def __truediv__(self, other: iacb_series, /) -> acb_series: ...
    def __rtruediv__(self, other: iacb_series, /) -> acb_series: ...
    def __pow__(self, other: iacb_series, mod: None = ..., /) -> acb_series: ...
    def __rpow__(self, other: iacb_series, mod: None = ..., /) -> acb_series: ...

    def valuation(self) -> int: ...

    def __call__(self, other: acb_series, /) -> acb_series: ...
    def reversion(self) -> acb_series: ...
    def inv(self) -> acb_series: ...
    def derivative(self) -> acb_series: ...
    def integral(self) -> acb_series: ...

    def sqrt(self) -> acb_series: ...
    def rsqrt(self) -> acb_series: ...
    def exp(self) -> acb_series: ...
    def log(self) -> acb_series: ...
    def atan(self) -> acb_series: ...
    def sin(self) -> acb_series: ...
    def cos(self) -> acb_series: ...
    def sin_cos(self) -> tuple[acb_series, acb_series]: ...
    def sin_pi(self) -> acb_series: ...
    def cos_pi(self) -> acb_series: ...
    def sin_cos_pi(self) -> tuple[acb_series, acb_series]: ...
    def cot_pi(self) -> acb_series: ...
    def tan(self) -> acb_series: ...

    def gamma(self) -> acb_series: ...
    def rgamma(self) -> acb_series: ...
    def lgamma(self) -> acb_series: ...
    def rising(self, n: int, /) -> acb_series: ...
    def zeta(self, a: iacb = ..., deflate: bool = ...) -> acb_series: ...
    def dirichlet_l(self, chi: tuple[int, int], deflate: bool = ...) -> acb_series: ...

    @classmethod
    def polylog(cls, s: iacb_series, z: iacb) -> acb_series: ...

    def agm(self, t: iacb_series | None = ...) -> acb_series: ...
    def elliptic_k(self) -> acb_series: ...
    def elliptic_p(self, tau: iacb, /) -> acb_series: ...

    def erf(self) -> acb_series: ...
    def erfc(self) -> acb_series: ...
    def erfi(self) -> acb_series: ...

    @classmethod
    def gamma_upper(cls, s: iacb, z: iacb_series, regularized: int = ...) -> acb_series: ...
    @classmethod
    def gamma_lower(cls, s: iacb, z: iacb_series, regularized: int = ...) -> acb_series: ...
    @classmethod
    def beta_lower(cls, a: iacb, b: iacb, z: iacb_series, regularized: int = ...) -> acb_series: ...
    @classmethod
    def hypgeom(cls, a: Sequence[iacb_series], b: Sequence[iacb_series], z: iacb_series, n: int = ..., regularized: bool = ...) -> acb_series: ...

    def airy_ai(self) -> acb_series: ...
    def airy_ai_prime(self) -> acb_series: ...
    def airy_bi(self) -> acb_series: ...
    def airy_bi_prime(self) -> acb_series: ...
    def airy(self) -> tuple[acb_series, acb_series, acb_series, acb_series]: ...

    def modular_theta(self, tau: iacb, /) -> tuple[acb_series, acb_series, acb_series, acb_series]: ...
    def coulomb(self, l: iacb, eta: iacb) -> tuple[acb_series, acb_series, acb_series, acb_series]: ...
    def coulomb_f(self, l: iacb, eta: iacb) -> acb_series: ...
    def coulomb_g(self, l: iacb, eta: iacb) -> acb_series: ...

    def fresnel(self, normalized: bool = ...) -> tuple[acb_series, acb_series]: ...
    def fresnel_s(self, normalized: bool = ...) -> acb_series: ...
    def fresnel_c(self, normalized: bool = ...) -> acb_series: ...
    def ei(self) -> acb_series: ...
    def si(self) -> acb_series: ...
    def ci(self) -> acb_series: ...
    def shi(self) -> acb_series: ...
    def chi(self) -> acb_series: ...
    def li(self, offset: bool = ...) -> acb_series: ...

    def lambertw(self, branch: int = ...) -> acb_series: ...

from typing import Literal, Protocol, overload

from ..flint_base.flint_base import flint_scalar
from .arf import arf
from .fmpq import fmpq as fmpq_t
from .fmpz import fmpz as fmpz_t


_str = str
ifmpz = int | fmpz_t
ifmpq = int | fmpz_t | fmpq_t
iarf = int | float | fmpz_t | fmpq_t | arf
iarb = int | float | fmpz_t | fmpq_t | arf | arb


class _MpfLike(Protocol):
    _mpf_: tuple[int, int, int, int]


class arb(flint_scalar):
    def __init__(
        self,
        mid: iarb | tuple[ifmpz, ifmpz] | _str | _MpfLike | None = ...,
        rad: iarb | tuple[ifmpz, ifmpz] | _str | None = ...,
    ) -> None: ...

    def is_zero(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_nan(self) -> bool: ...
    def is_exact(self) -> bool: ...
    def is_integer(self) -> bool: ...

    def man_exp(self) -> tuple[fmpz_t, fmpz_t]: ...
    def fmpq(self) -> fmpq_t: ...
    def fmpz(self) -> fmpz_t: ...

    def mid(self) -> arb: ...
    def rad(self) -> arb: ...
    def abs_lower(self) -> arb: ...
    def abs_upper(self) -> arb: ...
    def lower(self) -> arb: ...
    def upper(self) -> arb: ...
    def mid_rad_10exp(self, n: int = 0) -> tuple[fmpz_t, fmpz_t, fmpz_t]: ...

    @property
    def _mpf_(self) -> tuple[int, int, int, int]: ...

    def repr(self) -> _str: ...
    def str(self, n: int = 0, radius: bool = True, more: bool = False, condense: int = 0) -> _str: ...
    def __str__(self) -> _str: ...
    def __repr__(self) -> _str: ...

    def __float__(self) -> float: ...
    def __eq__(self, other: object, /) -> bool: ...
    def __lt__(self, other: iarb, /) -> bool: ...
    def __le__(self, other: iarb, /) -> bool: ...
    def __gt__(self, other: iarb, /) -> bool: ...
    def __ge__(self, other: iarb, /) -> bool: ...
    def __hash__(self) -> int: ...

    def __contains__(self, other: iarb, /) -> bool: ...
    def contains(self, other: iarb, /) -> bool: ...
    def contains_interior(self, other: iarb, /) -> bool: ...
    def overlaps(self, other: iarb, /) -> bool: ...
    def contains_integer(self) -> bool: ...

    @property
    def real(self) -> arb: ...
    @property
    def imag(self) -> arb: ...

    def __pos__(self) -> arb: ...
    def __neg__(self) -> arb: ...
    def neg(self, exact: bool = False) -> arb: ...
    def __abs__(self) -> arb: ...
    def sgn(self) -> arb: ...

    def __add__(self, other: iarb, /) -> arb: ...
    def __radd__(self, other: iarb, /) -> arb: ...
    def __sub__(self, other: iarb, /) -> arb: ...
    def __rsub__(self, other: iarb, /) -> arb: ...
    def __mul__(self, other: iarb, /) -> arb: ...
    def __rmul__(self, other: iarb, /) -> arb: ...
    def __truediv__(self, other: iarb, /) -> arb: ...
    def __rtruediv__(self, other: iarb, /) -> arb: ...
    def __pow__(self, other: iarb, modulus: None = ..., /) -> arb: ...
    def __rpow__(self, other: iarb, modulus: None = ..., /) -> arb: ...

    def floor(self) -> arb: ...
    def ceil(self) -> arb: ...

    def sqrt(self) -> arb: ...
    def rsqrt(self) -> arb: ...
    def exp(self) -> arb: ...
    def expm1(self) -> arb: ...
    def log(self) -> arb: ...
    def log1p(self) -> arb: ...
    def log_base(self, b: int) -> arb: ...

    def sin(self) -> arb: ...
    def cos(self) -> arb: ...
    def sin_cos(self) -> tuple[arb, arb]: ...
    def sin_pi(self) -> arb: ...
    def cos_pi(self) -> arb: ...
    def sin_cos_pi(self) -> tuple[arb, arb]: ...
    def tan(self) -> arb: ...
    def cot(self) -> arb: ...
    def tan_pi(self) -> arb: ...
    def cot_pi(self) -> arb: ...
    @staticmethod
    def sin_pi_fmpq(s: fmpq_t) -> arb: ...
    @staticmethod
    def cos_pi_fmpq(s: fmpq_t) -> arb: ...
    @staticmethod
    def sin_cos_pi_fmpq(s: fmpq_t) -> tuple[arb, arb]: ...
    def sec(self) -> arb: ...
    def csc(self) -> arb: ...
    def sinc(self) -> arb: ...
    def sinc_pi(self) -> arb: ...

    def atan(self) -> arb: ...
    @staticmethod
    def atan2(s: iarb, t: iarb) -> arb: ...
    def acos(self) -> arb: ...
    def asin(self) -> arb: ...
    def atanh(self) -> arb: ...
    def asinh(self) -> arb: ...
    def acosh(self) -> arb: ...

    def sinh(self) -> arb: ...
    def cosh(self) -> arb: ...
    def sinh_cosh(self) -> tuple[arb, arb]: ...
    def tanh(self) -> arb: ...
    def coth(self) -> arb: ...
    def sech(self) -> arb: ...
    def csch(self) -> arb: ...

    def gamma(self) -> arb: ...
    @staticmethod
    def gamma_fmpq(s: fmpq_t) -> arb: ...
    def rgamma(self) -> arb: ...
    def lgamma(self) -> arb: ...
    def digamma(self) -> arb: ...
    def rising(self, n: iarb) -> arb: ...
    @staticmethod
    def rising_fmpq_ui(s: fmpq_t, n: int) -> arb: ...
    def rising2(self, n: int) -> tuple[arb, arb]: ...

    def zeta(self, a: iarb | None = None) -> arb: ...
    def agm(self, t: iarb = 1) -> arb: ...

    @staticmethod
    def bernoulli(n: int) -> arb: ...
    @staticmethod
    def bell_number(n: int) -> arb: ...
    @staticmethod
    def partitions_p(n: int) -> arb: ...
    def bernoulli_poly(self, n: int) -> arb: ...

    def fac(self) -> arb: ...
    @staticmethod
    def fac_ui(n: int) -> arb: ...
    def bin(self, k: int) -> arb: ...
    @staticmethod
    def bin_uiui(n: int, k: int) -> arb: ...
    @staticmethod
    def fib(n: int) -> arb: ...

    def polylog(self, s: iarb) -> arb: ...

    def airy_ai(self, derivative: int = 0) -> arb: ...
    def airy_bi(self, derivative: int = 0) -> arb: ...
    def airy(self) -> tuple[arb, arb, arb, arb]: ...
    @staticmethod
    def airy_ai_zero(n: int, derivative: int = 0) -> arb: ...
    @staticmethod
    def airy_bi_zero(n: int, derivative: int = 0) -> arb: ...

    def chebyshev_t(self, n: iarb) -> arb: ...
    def chebyshev_u(self, n: iarb) -> arb: ...
    def jacobi_p(self, n: iarb, a: iarb, b: iarb) -> arb: ...
    def gegenbauer_c(self, n: iarb, m: iarb) -> arb: ...
    def laguerre_l(self, n: iarb, m: iarb = 0) -> arb: ...
    def hermite_h(self, n: iarb) -> arb: ...
    def legendre_p(self, n: iarb, m: iarb = 0, type: int = 2) -> arb: ...
    def legendre_q(self, n: iarb, m: iarb = 0, type: int = 2) -> arb: ...
    @staticmethod
    @overload
    @staticmethod
    def legendre_p_root(n: int, k: int, weight: Literal[False] = False) -> arb: ...
    @overload
    @staticmethod
    def legendre_p_root(n: int, k: int, weight: Literal[True]) -> tuple[arb, arb]: ...

    def erf(self) -> arb: ...
    def erfc(self) -> arb: ...
    def erfinv(self) -> arb: ...
    def erfcinv(self) -> arb: ...
    def erfi(self) -> arb: ...

    def fresnel_s(self, normalized: bool = True) -> arb: ...
    def fresnel_c(self, normalized: bool = True) -> arb: ...
    def ei(self) -> arb: ...
    def si(self) -> arb: ...
    def ci(self) -> arb: ...
    def shi(self) -> arb: ...
    def chi(self) -> arb: ...
    def li(self, offset: bool = False) -> arb: ...

    def bessel_j(self, n: iarb) -> arb: ...
    def bessel_y(self, n: iarb) -> arb: ...
    def bessel_k(self, n: iarb, scaled: bool = False) -> arb: ...
    def bessel_i(self, n: iarb, scaled: bool = False) -> arb: ...

    def gamma_upper(self, s: iarb, regularized: int = 0) -> arb: ...
    def gamma_lower(self, s: iarb, regularized: int = 0) -> arb: ...
    def beta_lower(self, a: iarb, b: iarb, regularized: int = 0) -> arb: ...
    def expint(self, s: iarb) -> arb: ...

    def hypgeom(self, a: list[iarb], b: list[iarb], regularized: bool = False) -> arb: ...
    def hypgeom_u(self, a: iarb, b: iarb) -> arb: ...
    def hypgeom_1f1(self, a: iarb, b: iarb, regularized: bool = False) -> arb: ...
    def hypgeom_0f1(self, a: iarb, regularized: bool = False) -> arb: ...
    def hypgeom_2f1(
        self,
        a: iarb,
        b: iarb,
        c: iarb,
        regularized: bool = False,
        ab: bool = False,
        ac: bool = False,
        bc: bool = False,
        abc: bool = False,
    ) -> arb: ...

    @staticmethod
    def pi() -> arb: ...
    @staticmethod
    def const_sqrt_pi() -> arb: ...
    @staticmethod
    def const_log2() -> arb: ...
    @staticmethod
    def const_log10() -> arb: ...
    @staticmethod
    def const_euler() -> arb: ...
    @staticmethod
    def const_catalan() -> arb: ...
    @staticmethod
    def const_e() -> arb: ...
    @staticmethod
    def const_khinchin() -> arb: ...
    @staticmethod
    def const_glaisher() -> arb: ...

    @staticmethod
    def pos_inf() -> arb: ...
    @staticmethod
    def neg_inf() -> arb: ...
    @staticmethod
    def nan() -> arb: ...

    def unique_fmpz(self) -> fmpz_t | None: ...
    def rel_accuracy_bits(self) -> int: ...
    def rel_one_accuracy_bits(self) -> int: ...
    def bits(self) -> int: ...
    def lambertw(self, branch: int = 0) -> arb: ...

    def nonnegative_part(self) -> arb: ...
    def union(self, t: iarb) -> arb: ...
    def intersection(self, t: iarb) -> arb: ...
    def min(self, t: iarb) -> arb: ...
    def max(self, t: iarb) -> arb: ...
    def root(self, n: int) -> arb: ...

    @staticmethod
    def gram_point(n: int) -> arb: ...
    def zeta_nzeros(self) -> arb: ...
    def backlund_s(self) -> arb: ...
    def coulomb(self, l: iarb, eta: iarb) -> tuple[arb, arb]: ...
    def coulomb_f(self, l: iarb, eta: iarb) -> arb: ...
    def coulomb_g(self, l: iarb, eta: iarb) -> arb: ...
